   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"Ap_ST32BL.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.Ap_ST32BL_Init,"ax",%progbits
  19              		.align	1
  20              		.global	Ap_ST32BL_Init
  21              		.thumb
  22              		.thumb_func
  24              	Ap_ST32BL_Init:
  25              	.LFB0:
  26              		.file 1 "../LIB_AP/Lib/Ap_ST32BL.c"
   1:../LIB_AP/Lib/Ap_ST32BL.c **** //----------------------------------------------------------------------------
   2:../LIB_AP/Lib/Ap_ST32BL.c **** //    프로그램명 	: ST32BL 관련 함수
   3:../LIB_AP/Lib/Ap_ST32BL.c **** //
   4:../LIB_AP/Lib/Ap_ST32BL.c **** //    만든이     	: 
   5:../LIB_AP/Lib/Ap_ST32BL.c **** //
   6:../LIB_AP/Lib/Ap_ST32BL.c **** //    날  짜     	: 
   7:../LIB_AP/Lib/Ap_ST32BL.c **** //    
   8:../LIB_AP/Lib/Ap_ST32BL.c **** //    최종 수정  	: 
   9:../LIB_AP/Lib/Ap_ST32BL.c **** //
  10:../LIB_AP/Lib/Ap_ST32BL.c **** //    MPU_Type 		:
  11:../LIB_AP/Lib/Ap_ST32BL.c **** //
  12:../LIB_AP/Lib/Ap_ST32BL.c **** //    파일명     	: AP_ST32BL.c
  13:../LIB_AP/Lib/Ap_ST32BL.c **** //----------------------------------------------------------------------------
  14:../LIB_AP/Lib/Ap_ST32BL.c **** 
  15:../LIB_AP/Lib/Ap_ST32BL.c **** 
  16:../LIB_AP/Lib/Ap_ST32BL.c **** 
  17:../LIB_AP/Lib/Ap_ST32BL.c **** 
  18:../LIB_AP/Lib/Ap_ST32BL.c **** 
  19:../LIB_AP/Lib/Ap_ST32BL.c **** //----- 헤더파일 열기
  20:../LIB_AP/Lib/Ap_ST32BL.c **** //
  21:../LIB_AP/Lib/Ap_ST32BL.c **** #define  AP_ST32BL_LOCAL  
  22:../LIB_AP/Lib/Ap_ST32BL.c **** 
  23:../LIB_AP/Lib/Ap_ST32BL.c **** #include "Ap_ST32BL.h"
  24:../LIB_AP/Lib/Ap_ST32BL.c **** #include "stm32f10x_flash.h"
  25:../LIB_AP/Lib/Ap_ST32BL.c **** 
  26:../LIB_AP/Lib/Ap_ST32BL.c **** #include <ctype.h>
  27:../LIB_AP/Lib/Ap_ST32BL.c **** #include <string.h>
  28:../LIB_AP/Lib/Ap_ST32BL.c **** 
  29:../LIB_AP/Lib/Ap_ST32BL.c **** 
  30:../LIB_AP/Lib/Ap_ST32BL.c **** //-- 내부 선언
  31:../LIB_AP/Lib/Ap_ST32BL.c **** //
  32:../LIB_AP/Lib/Ap_ST32BL.c **** 
  33:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_ST32BL_USE_DEBUG				0
  34:../LIB_AP/Lib/Ap_ST32BL.c **** 
  35:../LIB_AP/Lib/Ap_ST32BL.c **** 
  36:../LIB_AP/Lib/Ap_ST32BL.c **** 
  37:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_ST32BL_FLASH_START_ADDRESS 	((u32)0x08003000)
  38:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_ST32BL_FLASH_PAGE_SIZE    	((u16)0x00000400)
  39:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_ST32BL_FLASH_END_ADDRESS		((u32)0x08020000)
  40:../LIB_AP/Lib/Ap_ST32BL.c **** //#define HW_ST32BL_FLASH_END_ADDRESS	((u32)0x0800FFFF)
  41:../LIB_AP/Lib/Ap_ST32BL.c **** 
  42:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_ST32BL_FLASH_ADDRESS_OFFSET 	((u32)0x0003000)
  43:../LIB_AP/Lib/Ap_ST32BL.c **** 
  44:../LIB_AP/Lib/Ap_ST32BL.c **** 
  45:../LIB_AP/Lib/Ap_ST32BL.c **** #define HW_STM32_WRITE_BUFSIZE			256
  46:../LIB_AP/Lib/Ap_ST32BL.c **** 
  47:../LIB_AP/Lib/Ap_ST32BL.c **** 
  48:../LIB_AP/Lib/Ap_ST32BL.c **** //-- 내부 변수
  49:../LIB_AP/Lib/Ap_ST32BL.c **** //
  50:../LIB_AP/Lib/Ap_ST32BL.c **** 
  51:../LIB_AP/Lib/Ap_ST32BL.c **** u8	Ap_ST32BL_EraseSectorFlag[128];
  52:../LIB_AP/Lib/Ap_ST32BL.c **** 
  53:../LIB_AP/Lib/Ap_ST32BL.c **** 
  54:../LIB_AP/Lib/Ap_ST32BL.c **** typedef  void (*pFunction)(void);
  55:../LIB_AP/Lib/Ap_ST32BL.c **** 
  56:../LIB_AP/Lib/Ap_ST32BL.c **** 
  57:../LIB_AP/Lib/Ap_ST32BL.c **** 
  58:../LIB_AP/Lib/Ap_ST32BL.c **** void Ap_ST32BL_SendByte( u8 ByteData );
  59:../LIB_AP/Lib/Ap_ST32BL.c **** u8 	 Ap_ST32BL_WaitCmd( void );
  60:../LIB_AP/Lib/Ap_ST32BL.c **** u8   Ap_ST32BL_CheckFlashSector( u32 Address );
  61:../LIB_AP/Lib/Ap_ST32BL.c **** 
  62:../LIB_AP/Lib/Ap_ST32BL.c **** 
  63:../LIB_AP/Lib/Ap_ST32BL.c **** 
  64:../LIB_AP/Lib/Ap_ST32BL.c **** 
  65:../LIB_AP/Lib/Ap_ST32BL.c **** 
  66:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
  67:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_Init
  68:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
  69:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
  70:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
  71:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
  72:../LIB_AP/Lib/Ap_ST32BL.c **** void Ap_ST32BL_Init( void )
  73:../LIB_AP/Lib/Ap_ST32BL.c **** {
  27              		.loc 1 73 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  74:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 i;
  75:../LIB_AP/Lib/Ap_ST32BL.c **** 
  76:../LIB_AP/Lib/Ap_ST32BL.c **** 
  77:../LIB_AP/Lib/Ap_ST32BL.c **** 	//-- GPIO 입력핀으로 부트로더 실행 검사  
  78:../LIB_AP/Lib/Ap_ST32BL.c **** 	//
  79:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_GPIOB_CRL &= ~(0x0F << (0));	// Clear
  32              		.loc 1 79 0
  33 0000 184B     		ldr	r3, .L12
  34 0002 1A68     		ldr	r2, [r3, #0]
  35 0004 22F00F00 		bic	r0, r2, #15
  36 0008 1860     		str	r0, [r3, #0]
  80:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_GPIOB_CRL |=  (0x00 << (0));	// MODE, PB.0 Input Mode
  37              		.loc 1 80 0
  38 000a 1968     		ldr	r1, [r3, #0]
  39 000c 1960     		str	r1, [r3, #0]
  81:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_GPIOB_CRL |=  (0x02 << (2));	// CNF,  PB.0 input	pull-up/pull-down
  40              		.loc 1 81 0
  41 000e 1A68     		ldr	r2, [r3, #0]
  42 0010 42F00800 		orr	r0, r2, #8
  43 0014 1860     		str	r0, [r3, #0]
  82:../LIB_AP/Lib/Ap_ST32BL.c **** 		
  83:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT( REG_GPIOB_ODR, 0 );
  44              		.loc 1 83 0
  45 0016 D968     		ldr	r1, [r3, #12]
  46 0018 21F00102 		bic	r2, r1, #1
  47 001c DA60     		str	r2, [r3, #12]
  84:../LIB_AP/Lib/Ap_ST32BL.c **** 
  85:../LIB_AP/Lib/Ap_ST32BL.c **** 
  86:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( IS_SET_BIT(REG_GPIOB_IDR, 0) )
  48              		.loc 1 86 0
  49 001e 0833     		adds	r3, r3, #8
  50 0020 1B68     		ldr	r3, [r3, #0]
  51 0022 1149     		ldr	r1, .L12+4
  52 0024 13F00100 		ands	r0, r3, #1
  87:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
  88:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = TRUE;
  53              		.loc 1 88 0
  54 0028 18BF     		it	ne
  55 002a 0120     		movne	r0, #1
  89:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
  90:../LIB_AP/Lib/Ap_ST32BL.c **** 	else
  91:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
  92:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = FALSE;
  93:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
  94:../LIB_AP/Lib/Ap_ST32BL.c **** 
  95:../LIB_AP/Lib/Ap_ST32BL.c **** 
  96:../LIB_AP/Lib/Ap_ST32BL.c **** 	//-- 워치독 리셋이면 부트로더 실행 
  97:../LIB_AP/Lib/Ap_ST32BL.c **** 	//
  98:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( REG_RCC_CSR & (1<<29) )
  56              		.loc 1 98 0
  57 002c 0F4B     		ldr	r3, .L12+8
  92:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = FALSE;
  58              		.loc 1 92 0
  59 002e 0870     		strb	r0, [r1, #0]
  60              		.loc 1 98 0
  61 0030 1A68     		ldr	r2, [r3, #0]
  62 0032 9200     		lsls	r2, r2, #2
  63 0034 05D5     		bpl	.L4
  99:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 100:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = TRUE;
  64              		.loc 1 100 0
  65 0036 0C49     		ldr	r1, .L12+4
  66 0038 0120     		movs	r0, #1
 101:../LIB_AP/Lib/Ap_ST32BL.c **** 
 102:../LIB_AP/Lib/Ap_ST32BL.c **** 		REG_RCC_CSR = (1<<24);		// Clear Bit
  67              		.loc 1 102 0
  68 003a 4FF08072 		mov	r2, #16777216
 100:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = TRUE;
  69              		.loc 1 100 0
  70 003e 0870     		strb	r0, [r1, #0]
  71              		.loc 1 102 0
  72 0040 1A60     		str	r2, [r3, #0]
  73              	.L4:
 103:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 104:../LIB_AP/Lib/Ap_ST32BL.c **** 
 105:../LIB_AP/Lib/Ap_ST32BL.c **** 
 106:../LIB_AP/Lib/Ap_ST32BL.c **** 	//-- 펌웨어가 없어도 부트로더 실행
 107:../LIB_AP/Lib/Ap_ST32BL.c **** 	//
 108:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( *(u32 *)(HW_ST32BL_FLASH_START_ADDRESS+ 4) == 0xFFFFFFFF )
  74              		.loc 1 108 0
  75 0042 0B4B     		ldr	r3, .L12+12
  76 0044 1868     		ldr	r0, [r3, #0]
  77 0046 431C     		adds	r3, r0, #1
  78 0048 02D1     		bne	.L5
 109:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 110:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_RunBoot = TRUE;
  79              		.loc 1 110 0
  80 004a 074A     		ldr	r2, .L12+4
  81 004c 0121     		movs	r1, #1
  82 004e 1170     		strb	r1, [r2, #0]
  83              	.L5:
  84              	.LVL0:
  73:../LIB_AP/Lib/Ap_ST32BL.c **** {
  85              		.loc 1 73 0 discriminator 1
  86 0050 0023     		movs	r3, #0
  87              	.LVL1:
  88              	.L6:
 111:../LIB_AP/Lib/Ap_ST32BL.c **** 	}	
 112:../LIB_AP/Lib/Ap_ST32BL.c **** 
 113:../LIB_AP/Lib/Ap_ST32BL.c **** 
 114:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<128; i++ )
 115:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 116:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_EraseSectorFlag[i] = FALSE;
  89              		.loc 1 116 0 discriminator 2
  90 0052 0849     		ldr	r1, .L12+16
  91 0054 0020     		movs	r0, #0
  92 0056 5854     		strb	r0, [r3, r1]
 114:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<128; i++ )
  93              		.loc 1 114 0 discriminator 2
  94 0058 0133     		adds	r3, r3, #1
  95              	.LVL2:
  96 005a 802B     		cmp	r3, #128
  97 005c F9D1     		bne	.L6
 117:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 118:../LIB_AP/Lib/Ap_ST32BL.c **** 
 119:../LIB_AP/Lib/Ap_ST32BL.c **** 	Ap_ST32BL_UartPort = HW_UART_COM1;	
  98              		.loc 1 119 0
  99 005e 064A     		ldr	r2, .L12+20
 100 0060 1070     		strb	r0, [r2, #0]
 101 0062 7047     		bx	lr
 102              	.L13:
 103              		.align	2
 104              	.L12:
 105 0064 000C0140 		.word	1073810432
 106 0068 00000000 		.word	Ap_ST32BL_RunBoot
 107 006c 24100240 		.word	1073877028
 108 0070 04300008 		.word	134230020
 109 0074 00000000 		.word	Ap_ST32BL_EraseSectorFlag
 110 0078 00000000 		.word	Ap_ST32BL_UartPort
 111              		.cfi_endproc
 112              	.LFE0:
 114              		.section	.text.Ap_ST32BL_SendByte,"ax",%progbits
 115              		.align	1
 116              		.global	Ap_ST32BL_SendByte
 117              		.thumb
 118              		.thumb_func
 120              	Ap_ST32BL_SendByte:
 121              	.LFB3:
 120:../LIB_AP/Lib/Ap_ST32BL.c **** }
 121:../LIB_AP/Lib/Ap_ST32BL.c **** 
 122:../LIB_AP/Lib/Ap_ST32BL.c **** 
 123:../LIB_AP/Lib/Ap_ST32BL.c **** 
 124:../LIB_AP/Lib/Ap_ST32BL.c **** 
 125:../LIB_AP/Lib/Ap_ST32BL.c **** 
 126:../LIB_AP/Lib/Ap_ST32BL.c **** 
 127:../LIB_AP/Lib/Ap_ST32BL.c **** 
 128:../LIB_AP/Lib/Ap_ST32BL.c **** 
 129:../LIB_AP/Lib/Ap_ST32BL.c **** 
 130:../LIB_AP/Lib/Ap_ST32BL.c **** 
 131:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 132:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_Main
 133:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 134:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 135:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 136:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 137:../LIB_AP/Lib/Ap_ST32BL.c **** void Ap_ST32BL_Main( void )
 138:../LIB_AP/Lib/Ap_ST32BL.c **** {
 139:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8 	Cmd;
 140:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8 	Resp[300];
 141:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 Length;
 142:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 Address;
 143:../LIB_AP/Lib/Ap_ST32BL.c **** 
 144:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 i;
 145:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  CheckSum;
 146:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  CheckSumCalc;
 147:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  Ret;
 148:../LIB_AP/Lib/Ap_ST32BL.c **** 
 149:../LIB_AP/Lib/Ap_ST32BL.c **** 	while(1)
 150:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 151:../LIB_AP/Lib/Ap_ST32BL.c **** 		//Hw_Uart_Printf(HW_UART_VCOM, "ST32BL\n");
 152:../LIB_AP/Lib/Ap_ST32BL.c **** 		//Hw_Timer_Delay_ms(500);
 153:../LIB_AP/Lib/Ap_ST32BL.c **** 
 154:../LIB_AP/Lib/Ap_ST32BL.c **** 		Cmd = Ap_ST32BL_WaitCmd();
 155:../LIB_AP/Lib/Ap_ST32BL.c **** 
 156:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_INIT )
 157:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 158:../LIB_AP/Lib/Ap_ST32BL.c **** 
 159:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 160:../LIB_AP/Lib/Ap_ST32BL.c **** 
 161:../LIB_AP/Lib/Ap_ST32BL.c **** 
 162:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GET_COMMAND )
 163:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 164:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x00);
 165:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x22);
 166:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);
 167:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 168:../LIB_AP/Lib/Ap_ST32BL.c **** 
 169:../LIB_AP/Lib/Ap_ST32BL.c **** 
 170:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GET_ID )
 171:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 172:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x01);
 173:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x04);
 174:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x10);
 175:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);			
 176:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 177:../LIB_AP/Lib/Ap_ST32BL.c **** 
 178:../LIB_AP/Lib/Ap_ST32BL.c **** 
 179:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_ERASE_FLASH )
 180:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 181:../LIB_AP/Lib/Ap_ST32BL.c **** 			Resp[0] = Ap_ST32BL_ReceiveByte();
 182:../LIB_AP/Lib/Ap_ST32BL.c **** 			Resp[1] = Ap_ST32BL_ReceiveByte();
 183:../LIB_AP/Lib/Ap_ST32BL.c **** 
 184:../LIB_AP/Lib/Ap_ST32BL.c **** 
 185:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( Ap_ST32BL_EraseFlash() == TRUE )	Ap_ST32BL_SendByte(STM32_COMM_ACK);
 186:../LIB_AP/Lib/Ap_ST32BL.c **** 			else									Ap_ST32BL_SendByte(STM32_COMM_NACK);
 187:../LIB_AP/Lib/Ap_ST32BL.c **** 
 188:../LIB_AP/Lib/Ap_ST32BL.c **** 			#if HW_ST32BL_USE_DEBUG == 1
 189:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Uart_Printf(HW_UART_COM1, "Erase %x %x \r\n", Resp[0], Resp[1] );
 190:../LIB_AP/Lib/Ap_ST32BL.c **** 			#endif			
 191:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 192:../LIB_AP/Lib/Ap_ST32BL.c **** 
 193:../LIB_AP/Lib/Ap_ST32BL.c **** 
 194:../LIB_AP/Lib/Ap_ST32BL.c **** 
 195:../LIB_AP/Lib/Ap_ST32BL.c **** 
 196:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_WRITE_FLASH )
 197:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 198:../LIB_AP/Lib/Ap_ST32BL.c **** 
 199:../LIB_AP/Lib/Ap_ST32BL.c **** 			//-- Receive Address 
 200:../LIB_AP/Lib/Ap_ST32BL.c **** 			//
 201:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSumCalc = 0;
 202:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<4; i++ )
 203:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 204:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 205:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];	
 206:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 207:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 208:../LIB_AP/Lib/Ap_ST32BL.c **** 
 209:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 210:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 211:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 212:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;
 213:../LIB_AP/Lib/Ap_ST32BL.c **** 
 214:../LIB_AP/Lib/Ap_ST32BL.c **** 
 215:../LIB_AP/Lib/Ap_ST32BL.c **** 
 216:../LIB_AP/Lib/Ap_ST32BL.c **** 			#if HW_ST32BL_USE_DEBUG == 1
 217:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Uart_Printf(HW_UART_COM1, "Addrr %x %x %x %x %x %x\r\n", Resp[0], Resp[1], Resp[2], Resp[3], 
 218:../LIB_AP/Lib/Ap_ST32BL.c **** 			#endif		
 219:../LIB_AP/Lib/Ap_ST32BL.c **** 
 220:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( CheckSum == CheckSumCalc )
 221:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 222:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_ACK);
 223:../LIB_AP/Lib/Ap_ST32BL.c **** 				#if HW_ST32BL_USE_DEBUG == 1
 224:../LIB_AP/Lib/Ap_ST32BL.c **** 				Hw_Uart_Printf(HW_UART_COM1, "ACK\r\n");
 225:../LIB_AP/Lib/Ap_ST32BL.c **** 				#endif	
 226:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 227:../LIB_AP/Lib/Ap_ST32BL.c **** 			else
 228:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 229:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_NACK);	
 230:../LIB_AP/Lib/Ap_ST32BL.c **** 				#if HW_ST32BL_USE_DEBUG == 1
 231:../LIB_AP/Lib/Ap_ST32BL.c **** 				Hw_Uart_Printf(HW_UART_COM1, "NACK\r\n");
 232:../LIB_AP/Lib/Ap_ST32BL.c **** 				#endif	
 233:../LIB_AP/Lib/Ap_ST32BL.c **** 			}	
 234:../LIB_AP/Lib/Ap_ST32BL.c **** 
 235:../LIB_AP/Lib/Ap_ST32BL.c **** 
 236:../LIB_AP/Lib/Ap_ST32BL.c **** 			//-- Receive Data
 237:../LIB_AP/Lib/Ap_ST32BL.c **** 			//
 238:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSumCalc = 0;
 239:../LIB_AP/Lib/Ap_ST32BL.c **** 			Length  = Ap_ST32BL_ReceiveByte();
 240:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSumCalc ^= Length;
 241:../LIB_AP/Lib/Ap_ST32BL.c **** 			Length++;
 242:../LIB_AP/Lib/Ap_ST32BL.c **** 
 243:../LIB_AP/Lib/Ap_ST32BL.c **** 			#if HW_ST32BL_USE_DEBUG == 1
 244:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Uart_Printf(HW_UART_COM1, "Length %d \r\n", Length );
 245:../LIB_AP/Lib/Ap_ST32BL.c **** 			#endif	
 246:../LIB_AP/Lib/Ap_ST32BL.c **** 
 247:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<Length; i++ )
 248:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 249:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 250:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];					
 251:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 252:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 253:../LIB_AP/Lib/Ap_ST32BL.c **** 
 254:../LIB_AP/Lib/Ap_ST32BL.c **** 
 255:../LIB_AP/Lib/Ap_ST32BL.c **** 			#if HW_ST32BL_USE_DEBUG == 1
 256:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Uart_Printf(HW_UART_COM1, "Receive Data %d %x %x\r\n", Length, CheckSum, CheckSumCalc );
 257:../LIB_AP/Lib/Ap_ST32BL.c **** 			#endif		
 258:../LIB_AP/Lib/Ap_ST32BL.c **** 
 259:../LIB_AP/Lib/Ap_ST32BL.c **** 
 260:../LIB_AP/Lib/Ap_ST32BL.c **** 			//-- Flash Write
 261:../LIB_AP/Lib/Ap_ST32BL.c **** 			//
 262:../LIB_AP/Lib/Ap_ST32BL.c **** 
 263:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ret = Ap_ST32BL_WriteFlash( Address + HW_ST32BL_FLASH_ADDRESS_OFFSET, Resp, Length );
 264:../LIB_AP/Lib/Ap_ST32BL.c **** 
 265:../LIB_AP/Lib/Ap_ST32BL.c **** 		
 266:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( CheckSum == CheckSumCalc && Ret == TRUE ) 	
 267:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 268:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_ACK);
 269:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 270:../LIB_AP/Lib/Ap_ST32BL.c **** 			else							
 271:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 272:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_NACK);
 273:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 274:../LIB_AP/Lib/Ap_ST32BL.c **** 
 275:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 276:../LIB_AP/Lib/Ap_ST32BL.c **** 		
 277:../LIB_AP/Lib/Ap_ST32BL.c **** 
 278:../LIB_AP/Lib/Ap_ST32BL.c **** 		//-- Go Command
 279:../LIB_AP/Lib/Ap_ST32BL.c **** 		//
 280:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GO )
 281:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 282:../LIB_AP/Lib/Ap_ST32BL.c **** 			//-- Receive Address 
 283:../LIB_AP/Lib/Ap_ST32BL.c **** 			//
 284:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSumCalc = 0;
 285:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<4; i++ )
 286:../LIB_AP/Lib/Ap_ST32BL.c **** 			{
 287:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 288:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];	
 289:../LIB_AP/Lib/Ap_ST32BL.c **** 			}
 290:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 291:../LIB_AP/Lib/Ap_ST32BL.c **** 
 292:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 293:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 294:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 295:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;	
 296:../LIB_AP/Lib/Ap_ST32BL.c **** 			
 297:../LIB_AP/Lib/Ap_ST32BL.c **** 
 298:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);	
 299:../LIB_AP/Lib/Ap_ST32BL.c **** 
 300:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Timer_Delay_ms(100);
 301:../LIB_AP/Lib/Ap_ST32BL.c **** 
 302:../LIB_AP/Lib/Ap_ST32BL.c **** 			//-- Go
 303:../LIB_AP/Lib/Ap_ST32BL.c **** 			//
 304:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_JumpToApp( Address );
 305:../LIB_AP/Lib/Ap_ST32BL.c **** 
 306:../LIB_AP/Lib/Ap_ST32BL.c **** 					
 307:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 308:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 309:../LIB_AP/Lib/Ap_ST32BL.c **** 
 310:../LIB_AP/Lib/Ap_ST32BL.c **** }
 311:../LIB_AP/Lib/Ap_ST32BL.c **** 
 312:../LIB_AP/Lib/Ap_ST32BL.c **** 
 313:../LIB_AP/Lib/Ap_ST32BL.c **** 
 314:../LIB_AP/Lib/Ap_ST32BL.c **** 
 315:../LIB_AP/Lib/Ap_ST32BL.c **** 
 316:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 317:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_WaitCmd
 318:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 319:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 320:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 321:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 322:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_WaitCmd( void )
 323:../LIB_AP/Lib/Ap_ST32BL.c **** {
 324:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8 Ch;
 325:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8 Cmd = 0xFF;
 326:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8 CmdC;
 327:../LIB_AP/Lib/Ap_ST32BL.c **** 
 328:../LIB_AP/Lib/Ap_ST32BL.c **** 	Cmd = Ap_ST32BL_ReceiveByte();
 329:../LIB_AP/Lib/Ap_ST32BL.c **** 
 330:../LIB_AP/Lib/Ap_ST32BL.c **** 	switch( Cmd )
 331:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 332:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_INIT:
 333:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);
 334:../LIB_AP/Lib/Ap_ST32BL.c **** 			break;
 335:../LIB_AP/Lib/Ap_ST32BL.c **** 
 336:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_GET_COMMAND:
 337:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_ERASE_FLASH:
 338:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_EXTENDED_ERASE_FLASH:
 339:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_GET_ID:
 340:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_WRITE_FLASH:
 341:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_WRITE_UNPROTECT:
 342:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_READ_FLASH:
 343:../LIB_AP/Lib/Ap_ST32BL.c **** 		case STM32_CMD_GO:
 344:../LIB_AP/Lib/Ap_ST32BL.c **** 		case 0xFF:
 345:../LIB_AP/Lib/Ap_ST32BL.c **** 			CmdC = Ap_ST32BL_ReceiveByte();
 346:../LIB_AP/Lib/Ap_ST32BL.c **** 
 347:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);				
 348:../LIB_AP/Lib/Ap_ST32BL.c **** 			break;
 349:../LIB_AP/Lib/Ap_ST32BL.c **** 
 350:../LIB_AP/Lib/Ap_ST32BL.c **** 		default:
 351:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_NACK);
 352:../LIB_AP/Lib/Ap_ST32BL.c **** 			break;
 353:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 354:../LIB_AP/Lib/Ap_ST32BL.c **** 
 355:../LIB_AP/Lib/Ap_ST32BL.c **** 
 356:../LIB_AP/Lib/Ap_ST32BL.c **** 	return Cmd;
 357:../LIB_AP/Lib/Ap_ST32BL.c **** }
 358:../LIB_AP/Lib/Ap_ST32BL.c **** 
 359:../LIB_AP/Lib/Ap_ST32BL.c **** 
 360:../LIB_AP/Lib/Ap_ST32BL.c **** 
 361:../LIB_AP/Lib/Ap_ST32BL.c **** 
 362:../LIB_AP/Lib/Ap_ST32BL.c **** 
 363:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 364:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_SendByte
 365:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 366:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 367:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 368:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 369:../LIB_AP/Lib/Ap_ST32BL.c **** void Ap_ST32BL_SendByte( u8 ByteData )
 370:../LIB_AP/Lib/Ap_ST32BL.c **** {
 122              		.loc 1 370 0
 123              		.cfi_startproc
 124              		@ args = 0, pretend = 0, frame = 0
 125              		@ frame_needed = 0, uses_anonymous_args = 0
 126              	.LVL3:
 127 0000 08B5     		push	{r3, lr}
 128              	.LCFI0:
 129              		.cfi_def_cfa_offset 8
 130              		.cfi_offset 3, -8
 131              		.cfi_offset 14, -4
 371:../LIB_AP/Lib/Ap_ST32BL.c **** 	Hw_Uart_Putch( Ap_ST32BL_UartPort, ByteData );
 132              		.loc 1 371 0
 133 0002 034B     		ldr	r3, .L15
 370:../LIB_AP/Lib/Ap_ST32BL.c **** {
 134              		.loc 1 370 0
 135 0004 0146     		mov	r1, r0
 136              		.loc 1 371 0
 137 0006 034A     		ldr	r2, .L15+4
 138 0008 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 139              	.LVL4:
 140 000a 9047     		blx	r2
 141              	.LVL5:
 142 000c 08BD     		pop	{r3, pc}
 143              	.L16:
 144 000e 00BF     		.align	2
 145              	.L15:
 146 0010 00000000 		.word	Ap_ST32BL_UartPort
 147 0014 00000000 		.word	Hw_Uart_Putch
 148              		.cfi_endproc
 149              	.LFE3:
 151              		.section	.text.Ap_ST32BL_ReceiveByte,"ax",%progbits
 152              		.align	1
 153              		.global	Ap_ST32BL_ReceiveByte
 154              		.thumb
 155              		.thumb_func
 157              	Ap_ST32BL_ReceiveByte:
 158              	.LFB4:
 372:../LIB_AP/Lib/Ap_ST32BL.c **** }
 373:../LIB_AP/Lib/Ap_ST32BL.c **** 
 374:../LIB_AP/Lib/Ap_ST32BL.c **** 
 375:../LIB_AP/Lib/Ap_ST32BL.c **** 
 376:../LIB_AP/Lib/Ap_ST32BL.c **** 
 377:../LIB_AP/Lib/Ap_ST32BL.c **** 
 378:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 379:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_ReceiveByte
 380:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 381:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 382:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 383:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 384:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_ReceiveByte( void )
 385:../LIB_AP/Lib/Ap_ST32BL.c **** {
 159              		.loc 1 385 0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 0
 162              		@ frame_needed = 0, uses_anonymous_args = 0
 163 0000 08B5     		push	{r3, lr}
 164              	.LCFI1:
 165              		.cfi_def_cfa_offset 8
 166              		.cfi_offset 3, -8
 167              		.cfi_offset 14, -4
 386:../LIB_AP/Lib/Ap_ST32BL.c **** 	Hw_Uart_Getch( Ap_ST32BL_UartPort );
 168              		.loc 1 386 0
 169 0002 024B     		ldr	r3, .L18
 170 0004 0249     		ldr	r1, .L18+4
 171 0006 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 172 0008 8847     		blx	r1
 173              	.LVL6:
 387:../LIB_AP/Lib/Ap_ST32BL.c **** }
 174              		.loc 1 387 0
 175 000a 08BD     		pop	{r3, pc}
 176              	.L19:
 177              		.align	2
 178              	.L18:
 179 000c 00000000 		.word	Ap_ST32BL_UartPort
 180 0010 00000000 		.word	Hw_Uart_Getch
 181              		.cfi_endproc
 182              	.LFE4:
 184              		.section	.text.Ap_ST32BL_WaitCmd,"ax",%progbits
 185              		.align	1
 186              		.global	Ap_ST32BL_WaitCmd
 187              		.thumb
 188              		.thumb_func
 190              	Ap_ST32BL_WaitCmd:
 191              	.LFB2:
 323:../LIB_AP/Lib/Ap_ST32BL.c **** {
 192              		.loc 1 323 0
 193              		.cfi_startproc
 194              		@ args = 0, pretend = 0, frame = 0
 195              		@ frame_needed = 0, uses_anonymous_args = 0
 196              	.LVL7:
 197 0000 38B5     		push	{r3, r4, r5, lr}
 198              	.LCFI2:
 199              		.cfi_def_cfa_offset 16
 200              		.cfi_offset 3, -16
 201              		.cfi_offset 4, -12
 202              		.cfi_offset 5, -8
 203              		.cfi_offset 14, -4
 328:../LIB_AP/Lib/Ap_ST32BL.c **** 	Cmd = Ap_ST32BL_ReceiveByte();
 204              		.loc 1 328 0
 205 0002 134D     		ldr	r5, .L52
 206 0004 A847     		blx	r5
 207              	.LVL8:
 330:../LIB_AP/Lib/Ap_ST32BL.c **** 	switch( Cmd )
 208              		.loc 1 330 0
 209 0006 3128     		cmp	r0, #49
 210 0008 2B46     		mov	r3, r5
 328:../LIB_AP/Lib/Ap_ST32BL.c **** 	Cmd = Ap_ST32BL_ReceiveByte();
 211              		.loc 1 328 0
 212 000a 0446     		mov	r4, r0
 213              	.LVL9:
 214 000c 114D     		ldr	r5, .L52+4
 330:../LIB_AP/Lib/Ap_ST32BL.c **** 	switch( Cmd )
 215              		.loc 1 330 0
 216 000e 15D0     		beq	.L22
 217 0010 08D8     		bhi	.L24
 218 0012 0228     		cmp	r0, #2
 219 0014 12D0     		beq	.L22
 220 0016 01D8     		bhi	.L25
 221 0018 80B1     		cbz	r0, .L22
 222 001a 13E0     		b	.L21
 223              	.L25:
 224 001c 1128     		cmp	r0, #17
 225 001e 0DD0     		beq	.L22
 226 0020 2128     		cmp	r0, #33
 227 0022 0AE0     		b	.L50
 228              	.L24:
 229 0024 7328     		cmp	r0, #115
 230 0026 09D0     		beq	.L22
 231 0028 04D8     		bhi	.L26
 232 002a A0F14302 		sub	r2, r0, #67
 233 002e 012A     		cmp	r2, #1
 234 0030 08D8     		bhi	.L21
 235 0032 03E0     		b	.L22
 236              	.L26:
 237 0034 7F28     		cmp	r0, #127
 238 0036 02D0     		beq	.L51
 239 0038 FF28     		cmp	r0, #255
 240              	.L50:
 241 003a 03D1     		bne	.L21
 242              	.L22:
 345:../LIB_AP/Lib/Ap_ST32BL.c **** 			CmdC = Ap_ST32BL_ReceiveByte();
 243              		.loc 1 345 0
 244 003c 9847     		blx	r3
 245              	.LVL10:
 246              	.L51:
 347:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);				
 247              		.loc 1 347 0
 248 003e 7920     		movs	r0, #121
 249 0040 A847     		blx	r5
 250              	.LVL11:
 348:../LIB_AP/Lib/Ap_ST32BL.c **** 			break;
 251              		.loc 1 348 0
 252 0042 02E0     		b	.L27
 253              	.LVL12:
 254              	.L21:
 351:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_NACK);
 255              		.loc 1 351 0
 256 0044 1F20     		movs	r0, #31
 257              	.LVL13:
 258 0046 0349     		ldr	r1, .L52+4
 259 0048 8847     		blx	r1
 260              	.LVL14:
 261              	.L27:
 357:../LIB_AP/Lib/Ap_ST32BL.c **** }
 262              		.loc 1 357 0
 263 004a 2046     		mov	r0, r4
 264 004c 38BD     		pop	{r3, r4, r5, pc}
 265              	.L53:
 266 004e 00BF     		.align	2
 267              	.L52:
 268 0050 00000000 		.word	Ap_ST32BL_ReceiveByte
 269 0054 00000000 		.word	Ap_ST32BL_SendByte
 270              		.cfi_endproc
 271              	.LFE2:
 273              		.section	.text.Ap_ST32BL_EraseFlash,"ax",%progbits
 274              		.align	1
 275              		.global	Ap_ST32BL_EraseFlash
 276              		.thumb
 277              		.thumb_func
 279              	Ap_ST32BL_EraseFlash:
 280              	.LFB5:
 388:../LIB_AP/Lib/Ap_ST32BL.c **** 
 389:../LIB_AP/Lib/Ap_ST32BL.c **** 
 390:../LIB_AP/Lib/Ap_ST32BL.c **** 
 391:../LIB_AP/Lib/Ap_ST32BL.c **** 
 392:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 393:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_EraseFlash
 394:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 395:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 396:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 397:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 398:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_EraseFlash( void )
 399:../LIB_AP/Lib/Ap_ST32BL.c **** {
 281              		.loc 1 399 0
 282              		.cfi_startproc
 283              		@ args = 0, pretend = 0, frame = 8
 284              		@ frame_needed = 0, uses_anonymous_args = 0
 285              	.LVL15:
 286 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 287              	.LCFI3:
 288              		.cfi_def_cfa_offset 24
 289              		.cfi_offset 0, -24
 290              		.cfi_offset 1, -20
 291              		.cfi_offset 2, -16
 292              		.cfi_offset 4, -12
 293              		.cfi_offset 5, -8
 294              		.cfi_offset 14, -4
 400:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  Ret = TRUE;
 401:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 PageCount;
 402:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 i;
 403:../LIB_AP/Lib/Ap_ST32BL.c **** 
 404:../LIB_AP/Lib/Ap_ST32BL.c **** 	
 405:../LIB_AP/Lib/Ap_ST32BL.c **** 	volatile FLASH_Status FLASHStatus;
 406:../LIB_AP/Lib/Ap_ST32BL.c **** 
 407:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 295              		.loc 1 407 0
 296 0002 0423     		movs	r3, #4
 408:../LIB_AP/Lib/Ap_ST32BL.c **** 
 409:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASH_Unlock();
 297              		.loc 1 409 0
 298 0004 0E48     		ldr	r0, .L59
 407:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 299              		.loc 1 407 0
 300 0006 8DF80730 		strb	r3, [sp, #7]
 301              	.LVL16:
 302              		.loc 1 409 0
 303 000a 8047     		blx	r0
 304              	.LVL17:
 410:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
 305              		.loc 1 410 0
 306 000c 3520     		movs	r0, #53
 307 000e 0D49     		ldr	r1, .L59+4
 308 0010 8847     		blx	r1
 309              	.LVL18:
 411:../LIB_AP/Lib/Ap_ST32BL.c **** 
 412:../LIB_AP/Lib/Ap_ST32BL.c **** 
 413:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<128; i++ )
 310              		.loc 1 413 0
 311 0012 0022     		movs	r2, #0
 312              	.LVL19:
 313              	.L55:
 414:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 415:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_EraseSectorFlag[i] = FALSE;
 314              		.loc 1 415 0 discriminator 2
 315 0014 0C4D     		ldr	r5, .L59+8
 316 0016 0024     		movs	r4, #0
 317 0018 5455     		strb	r4, [r2, r5]
 413:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<128; i++ )
 318              		.loc 1 413 0 discriminator 2
 319 001a 0132     		adds	r2, r2, #1
 320              	.LVL20:
 321 001c 802A     		cmp	r2, #128
 322 001e F9D1     		bne	.L55
 323              	.LVL21:
 416:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 417:../LIB_AP/Lib/Ap_ST32BL.c **** 
 418:../LIB_AP/Lib/Ap_ST32BL.c **** 	PageCount = 0;
 419:../LIB_AP/Lib/Ap_ST32BL.c **** 
 420:../LIB_AP/Lib/Ap_ST32BL.c **** 
 421:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_ErasePage(HW_ST32BL_FLASH_START_ADDRESS);
 324              		.loc 1 421 0
 325 0020 0A48     		ldr	r0, .L59+12
 326 0022 0B4B     		ldr	r3, .L59+16
 327 0024 9847     		blx	r3
 328              	.LVL22:
 329 0026 8DF80700 		strb	r0, [sp, #7]
 422:../LIB_AP/Lib/Ap_ST32BL.c **** 
 423:../LIB_AP/Lib/Ap_ST32BL.c **** 	Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 424:../LIB_AP/Lib/Ap_ST32BL.c **** 
 425:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( FLASHStatus != FLASH_COMPLETE )
 330              		.loc 1 425 0
 331 002a 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 332              	.LVL23:
 423:../LIB_AP/Lib/Ap_ST32BL.c **** 	Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 333              		.loc 1 423 0
 334 002e 0120     		movs	r0, #1
 335              		.loc 1 425 0
 336 0030 0429     		cmp	r1, #4
 423:../LIB_AP/Lib/Ap_ST32BL.c **** 	Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 337              		.loc 1 423 0
 338 0032 2870     		strb	r0, [r5, #0]
 339              		.loc 1 425 0
 340 0034 02D0     		beq	.L56
 426:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 427:../LIB_AP/Lib/Ap_ST32BL.c **** 		FLASH_Lock();
 341              		.loc 1 427 0
 342 0036 0748     		ldr	r0, .L59+20
 343 0038 8047     		blx	r0
 344              	.LVL24:
 428:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ret = FALSE;
 345              		.loc 1 428 0
 346 003a 2046     		mov	r0, r4
 347              	.LVL25:
 348              	.L56:
 429:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 430:../LIB_AP/Lib/Ap_ST32BL.c **** 
 431:../LIB_AP/Lib/Ap_ST32BL.c **** 	return Ret;
 432:../LIB_AP/Lib/Ap_ST32BL.c **** }
 349              		.loc 1 432 0
 350 003c 3EBD     		pop	{r1, r2, r3, r4, r5, pc}
 351              	.L60:
 352 003e 00BF     		.align	2
 353              	.L59:
 354 0040 00000000 		.word	FLASH_Unlock
 355 0044 00000000 		.word	FLASH_ClearFlag
 356 0048 00000000 		.word	Ap_ST32BL_EraseSectorFlag
 357 004c 00300008 		.word	134230016
 358 0050 00000000 		.word	FLASH_ErasePage
 359 0054 00000000 		.word	FLASH_Lock
 360              		.cfi_endproc
 361              	.LFE5:
 363              		.section	.text.Ap_ST32BL_CheckFlashSector,"ax",%progbits
 364              		.align	1
 365              		.global	Ap_ST32BL_CheckFlashSector
 366              		.thumb
 367              		.thumb_func
 369              	Ap_ST32BL_CheckFlashSector:
 370              	.LFB6:
 433:../LIB_AP/Lib/Ap_ST32BL.c **** 
 434:../LIB_AP/Lib/Ap_ST32BL.c **** #if 0
 435:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_EraseFlash( void )
 436:../LIB_AP/Lib/Ap_ST32BL.c **** {
 437:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8   Ret = TRUE;
 438:../LIB_AP/Lib/Ap_ST32BL.c **** 
 439:../LIB_AP/Lib/Ap_ST32BL.c **** 	vu32 PageCount    = 0;
 440:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32  i;
 441:../LIB_AP/Lib/Ap_ST32BL.c **** 
 442:../LIB_AP/Lib/Ap_ST32BL.c **** 	volatile FLASH_Status FLASHStatus;
 443:../LIB_AP/Lib/Ap_ST32BL.c **** 
 444:../LIB_AP/Lib/Ap_ST32BL.c **** 
 445:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 446:../LIB_AP/Lib/Ap_ST32BL.c **** 
 447:../LIB_AP/Lib/Ap_ST32BL.c **** 
 448:../LIB_AP/Lib/Ap_ST32BL.c **** 
 449:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASH_Unlock();
 450:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
 451:../LIB_AP/Lib/Ap_ST32BL.c **** 
 452:../LIB_AP/Lib/Ap_ST32BL.c **** 
 453:../LIB_AP/Lib/Ap_ST32BL.c **** 	PageCount = ((HW_ST32BL_FLASH_END_ADDRESS - HW_ST32BL_FLASH_START_ADDRESS) / HW_ST32BL_FLASH_PAGE_
 454:../LIB_AP/Lib/Ap_ST32BL.c **** 
 455:../LIB_AP/Lib/Ap_ST32BL.c **** 
 456:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; (i < PageCount) && (FLASHStatus == FLASH_COMPLETE); i++ )
 457:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 458:../LIB_AP/Lib/Ap_ST32BL.c **** 		FLASHStatus = FLASH_ErasePage(HW_ST32BL_FLASH_START_ADDRESS + (HW_ST32BL_FLASH_PAGE_SIZE * i));
 459:../LIB_AP/Lib/Ap_ST32BL.c **** 
 460:../LIB_AP/Lib/Ap_ST32BL.c **** 		#if HW_ST32BL_USE_DEBUG == 1
 461:../LIB_AP/Lib/Ap_ST32BL.c **** 		//Hw_Uart_Printf(HW_UART_COM1, "Erase %d %x\r\n", i, FLASHStatus );
 462:../LIB_AP/Lib/Ap_ST32BL.c **** 		#endif			
 463:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 464:../LIB_AP/Lib/Ap_ST32BL.c **** 
 465:../LIB_AP/Lib/Ap_ST32BL.c **** 	#if HW_ST32BL_USE_DEBUG == 1
 466:../LIB_AP/Lib/Ap_ST32BL.c **** 	Hw_Uart_Printf(HW_UART_COM1, "Erase End %x\r\n", FLASHStatus );
 467:../LIB_AP/Lib/Ap_ST32BL.c **** 	#endif	
 468:../LIB_AP/Lib/Ap_ST32BL.c **** 
 469:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( FLASHStatus != FLASH_COMPLETE )
 470:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 471:../LIB_AP/Lib/Ap_ST32BL.c **** 		FLASH_Lock();
 472:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ret = FALSE;
 473:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 474:../LIB_AP/Lib/Ap_ST32BL.c **** 
 475:../LIB_AP/Lib/Ap_ST32BL.c **** 	return Ret;
 476:../LIB_AP/Lib/Ap_ST32BL.c **** }
 477:../LIB_AP/Lib/Ap_ST32BL.c **** #endif
 478:../LIB_AP/Lib/Ap_ST32BL.c **** 
 479:../LIB_AP/Lib/Ap_ST32BL.c **** 
 480:../LIB_AP/Lib/Ap_ST32BL.c **** 
 481:../LIB_AP/Lib/Ap_ST32BL.c **** 
 482:../LIB_AP/Lib/Ap_ST32BL.c **** 
 483:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 484:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_CheckFlashSector
 485:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 486:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 487:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 488:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 489:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_CheckFlashSector( u32 Address )
 490:../LIB_AP/Lib/Ap_ST32BL.c **** {
 371              		.loc 1 490 0
 372              		.cfi_startproc
 373              		@ args = 0, pretend = 0, frame = 8
 374              		@ frame_needed = 0, uses_anonymous_args = 0
 375              	.LVL26:
 376 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 377              	.LCFI4:
 378              		.cfi_def_cfa_offset 24
 379              		.cfi_offset 0, -24
 380              		.cfi_offset 1, -20
 381              		.cfi_offset 4, -16
 382              		.cfi_offset 5, -12
 383              		.cfi_offset 6, -8
 384              		.cfi_offset 14, -4
 491:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  Ret = TRUE;
 492:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 PageCount;
 493:../LIB_AP/Lib/Ap_ST32BL.c **** 
 494:../LIB_AP/Lib/Ap_ST32BL.c **** 	volatile FLASH_Status FLASHStatus;
 495:../LIB_AP/Lib/Ap_ST32BL.c **** 
 496:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 497:../LIB_AP/Lib/Ap_ST32BL.c **** 
 498:../LIB_AP/Lib/Ap_ST32BL.c **** 
 499:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( Address < HW_ST32BL_FLASH_START_ADDRESS	) return FALSE;
 385              		.loc 1 499 0
 386 0002 1149     		ldr	r1, .L69
 496:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 387              		.loc 1 496 0
 388 0004 0423     		movs	r3, #4
 389              		.loc 1 499 0
 390 0006 8842     		cmp	r0, r1
 496:../LIB_AP/Lib/Ap_ST32BL.c **** 	FLASHStatus = FLASH_COMPLETE;
 391              		.loc 1 496 0
 392 0008 8DF80730 		strb	r3, [sp, #7]
 393              	.LVL27:
 394              		.loc 1 499 0
 395 000c 19D9     		bls	.L65
 500:../LIB_AP/Lib/Ap_ST32BL.c **** 
 501:../LIB_AP/Lib/Ap_ST32BL.c **** 
 502:../LIB_AP/Lib/Ap_ST32BL.c **** 	PageCount = (Address - HW_ST32BL_FLASH_START_ADDRESS) / HW_ST32BL_FLASH_PAGE_SIZE;
 396              		.loc 1 502 0
 397 000e 00F17844 		add	r4, r0, #-134217728
 398 0012 A4F54050 		sub	r0, r4, #12288
 399              	.LVL28:
 503:../LIB_AP/Lib/Ap_ST32BL.c **** 
 504:../LIB_AP/Lib/Ap_ST32BL.c **** 
 505:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( Ap_ST32BL_EraseSectorFlag[PageCount] == FALSE )
 400              		.loc 1 505 0
 401 0016 0D4E     		ldr	r6, .L69+4
 502:../LIB_AP/Lib/Ap_ST32BL.c **** 	PageCount = (Address - HW_ST32BL_FLASH_START_ADDRESS) / HW_ST32BL_FLASH_PAGE_SIZE;
 402              		.loc 1 502 0
 403 0018 840A     		lsrs	r4, r0, #10
 404              	.LVL29:
 405              		.loc 1 505 0
 406 001a 355D     		ldrb	r5, [r6, r4]	@ zero_extendqisi2
 407 001c 0DB1     		cbz	r5, .L63
 408              	.LVL30:
 409              	.L64:
 491:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8  Ret = TRUE;
 410              		.loc 1 491 0
 411 001e 0120     		movs	r0, #1
 412              	.LVL31:
 413 0020 10E0     		b	.L62
 414              	.L63:
 506:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 507:../LIB_AP/Lib/Ap_ST32BL.c **** 		FLASHStatus = FLASH_ErasePage(HW_ST32BL_FLASH_START_ADDRESS + (HW_ST32BL_FLASH_PAGE_SIZE * PageCo
 415              		.loc 1 507 0
 416 0022 04F50032 		add	r2, r4, #131072
 417 0026 0C32     		adds	r2, r2, #12
 418 0028 9002     		lsls	r0, r2, #10
 419 002a 094B     		ldr	r3, .L69+8
 420 002c 9847     		blx	r3
 421              	.LVL32:
 422 002e 8DF80700 		strb	r0, [sp, #7]
 508:../LIB_AP/Lib/Ap_ST32BL.c **** 
 509:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 510:../LIB_AP/Lib/Ap_ST32BL.c **** 
 511:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( FLASHStatus != FLASH_COMPLETE )
 423              		.loc 1 511 0
 424 0032 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 425              	.LVL33:
 509:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 426              		.loc 1 509 0
 427 0036 0121     		movs	r1, #1
 428              		.loc 1 511 0
 429 0038 0428     		cmp	r0, #4
 509:../LIB_AP/Lib/Ap_ST32BL.c **** 		Ap_ST32BL_EraseSectorFlag[PageCount] = TRUE;
 430              		.loc 1 509 0
 431 003a 3155     		strb	r1, [r6, r4]
 432              		.loc 1 511 0
 433 003c EFD0     		beq	.L64
 512:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 513:../LIB_AP/Lib/Ap_ST32BL.c **** 			FLASH_Lock();
 434              		.loc 1 513 0
 435 003e 054A     		ldr	r2, .L69+12
 436 0040 9047     		blx	r2
 437              	.LVL34:
 438              	.L65:
 499:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( Address < HW_ST32BL_FLASH_START_ADDRESS	) return FALSE;
 439              		.loc 1 499 0
 440 0042 0020     		movs	r0, #0
 441              	.L62:
 514:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ret = FALSE;
 515:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 516:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 517:../LIB_AP/Lib/Ap_ST32BL.c **** 
 518:../LIB_AP/Lib/Ap_ST32BL.c **** 
 519:../LIB_AP/Lib/Ap_ST32BL.c **** 	return Ret;
 520:../LIB_AP/Lib/Ap_ST32BL.c **** }
 442              		.loc 1 520 0
 443 0044 7CBD     		pop	{r2, r3, r4, r5, r6, pc}
 444              	.L70:
 445 0046 00BF     		.align	2
 446              	.L69:
 447 0048 FF2F0008 		.word	134230015
 448 004c 00000000 		.word	Ap_ST32BL_EraseSectorFlag
 449 0050 00000000 		.word	FLASH_ErasePage
 450 0054 00000000 		.word	FLASH_Lock
 451              		.cfi_endproc
 452              	.LFE6:
 454              		.section	.text.Ap_ST32BL_WriteFlash,"ax",%progbits
 455              		.align	1
 456              		.global	Ap_ST32BL_WriteFlash
 457              		.thumb
 458              		.thumb_func
 460              	Ap_ST32BL_WriteFlash:
 461              	.LFB7:
 521:../LIB_AP/Lib/Ap_ST32BL.c **** 
 522:../LIB_AP/Lib/Ap_ST32BL.c **** 
 523:../LIB_AP/Lib/Ap_ST32BL.c **** 
 524:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 525:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_WriteFlash
 526:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 527:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 528:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 529:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 530:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_WriteFlash( u32 Address, u8 *pData, u32 DataSize )
 531:../LIB_AP/Lib/Ap_ST32BL.c **** {
 462              		.loc 1 531 0
 463              		.cfi_startproc
 464              		@ args = 0, pretend = 0, frame = 8
 465              		@ frame_needed = 0, uses_anonymous_args = 0
 466              	.LVL35:
 467 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 468              	.LCFI5:
 469              		.cfi_def_cfa_offset 32
 470              		.cfi_offset 0, -32
 471              		.cfi_offset 1, -28
 472              		.cfi_offset 4, -24
 473              		.cfi_offset 5, -20
 474              		.cfi_offset 6, -16
 475              		.cfi_offset 7, -12
 476              		.cfi_offset 8, -8
 477              		.cfi_offset 14, -4
 532:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 StartAddress = Address;
 533:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 WriteSize;
 534:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 WriteData;
 535:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 i;
 536:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 DataIndex;
 537:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8	Ret = TRUE;
 538:../LIB_AP/Lib/Ap_ST32BL.c **** 	volatile FLASH_Status FLASHStatus;
 539:../LIB_AP/Lib/Ap_ST32BL.c **** 
 540:../LIB_AP/Lib/Ap_ST32BL.c **** 
 541:../LIB_AP/Lib/Ap_ST32BL.c **** 	WriteSize = DataSize / 4;	// 32Bit로 변경 
 478              		.loc 1 541 0
 479 0004 9508     		lsrs	r5, r2, #2
 480              	.LVL36:
 531:../LIB_AP/Lib/Ap_ST32BL.c **** {
 481              		.loc 1 531 0
 482 0006 8846     		mov	r8, r1
 542:../LIB_AP/Lib/Ap_ST32BL.c **** 
 543:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( (WriteSize%4) > 0 ) WriteSize++;
 544:../LIB_AP/Lib/Ap_ST32BL.c **** 
 545:../LIB_AP/Lib/Ap_ST32BL.c **** 
 546:../LIB_AP/Lib/Ap_ST32BL.c **** 	//-- 섹터가 지워졌는지 검사
 547:../LIB_AP/Lib/Ap_ST32BL.c **** 	//
 548:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( Ap_ST32BL_CheckFlashSector(Address) == FALSE )
 483              		.loc 1 548 0
 484 0008 134B     		ldr	r3, .L83
 543:../LIB_AP/Lib/Ap_ST32BL.c **** 	if( (WriteSize%4) > 0 ) WriteSize++;
 485              		.loc 1 543 0
 486 000a A907     		lsls	r1, r5, #30
 487              	.LVL37:
 488 000c 18BF     		it	ne
 489 000e 0135     		addne	r5, r5, #1
 490              	.LVL38:
 531:../LIB_AP/Lib/Ap_ST32BL.c **** {
 491              		.loc 1 531 0
 492 0010 0746     		mov	r7, r0
 493              		.loc 1 548 0
 494 0012 9847     		blx	r3
 495              	.LVL39:
 496 0014 10B1     		cbz	r0, .L73
 497 0016 4446     		mov	r4, r8
 498 0018 0026     		movs	r6, #0
 499 001a 18E0     		b	.L74
 500              	.LVL40:
 501              	.L73:
 549:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 550:../LIB_AP/Lib/Ap_ST32BL.c **** 		return FALSE;
 502              		.loc 1 550 0
 503 001c 0020     		movs	r0, #0
 504              	.LVL41:
 505 001e 19E0     		b	.L75
 506              	.LVL42:
 507              	.L76:
 551:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 552:../LIB_AP/Lib/Ap_ST32BL.c **** 
 553:../LIB_AP/Lib/Ap_ST32BL.c **** 
 554:../LIB_AP/Lib/Ap_ST32BL.c **** 	DataIndex = 0;
 555:../LIB_AP/Lib/Ap_ST32BL.c **** 
 556:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<WriteSize; i++ )
 557:../LIB_AP/Lib/Ap_ST32BL.c **** 	{
 558:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData  = pData[ DataIndex++ ] << 0;
 559:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 8;
 508              		.loc 1 559 0
 509 0020 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 510              	.LVL43:
 560:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 16;
 511              		.loc 1 560 0
 512 0022 A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 559:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 8;
 513              		.loc 1 559 0
 514 0024 0302     		lsls	r3, r0, #8
 558:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData  = pData[ DataIndex++ ] << 0;
 515              		.loc 1 558 0
 516 0026 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 517              	.LVL44:
 559:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 8;
 518              		.loc 1 559 0
 519 0028 43EA0143 		orr	r3, r3, r1, lsl #16
 520              	.LVL45:
 561:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 24;
 521              		.loc 1 561 0
 522 002c E178     		ldrb	r1, [r4, #3]	@ zero_extendqisi2
 560:../LIB_AP/Lib/Ap_ST32BL.c **** 		WriteData |= pData[ DataIndex++ ] << 16;
 523              		.loc 1 560 0
 524 002e 42EA0161 		orr	r1, r2, r1, lsl #24
 525              	.LVL46:
 530:../LIB_AP/Lib/Ap_ST32BL.c **** u8 Ap_ST32BL_WriteFlash( u32 Address, u8 *pData, u32 DataSize )
 526              		.loc 1 530 0
 527 0032 C8EB0702 		rsb	r2, r8, r7
 562:../LIB_AP/Lib/Ap_ST32BL.c **** 
 563:../LIB_AP/Lib/Ap_ST32BL.c **** 		FLASHStatus = FLASH_ProgramWord(StartAddress+i*4, WriteData);
 528              		.loc 1 563 0
 529 0036 1019     		adds	r0, r2, r4
 530 0038 1943     		orrs	r1, r1, r3
 531              	.LVL47:
 532 003a 084B     		ldr	r3, .L83+4
 533 003c 9847     		blx	r3
 534              	.LVL48:
 535 003e 8DF80700 		strb	r0, [sp, #7]
 536              	.LVL49:
 564:../LIB_AP/Lib/Ap_ST32BL.c **** 
 565:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( FLASHStatus != FLASH_COMPLETE )
 537              		.loc 1 565 0
 538 0042 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 539              	.LVL50:
 540 0046 0434     		adds	r4, r4, #4
 541 0048 0428     		cmp	r0, #4
 542 004a E7D1     		bne	.L73
 556:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<WriteSize; i++ )
 543              		.loc 1 556 0
 544 004c 0136     		adds	r6, r6, #1
 545              	.LVL51:
 546              	.L74:
 556:../LIB_AP/Lib/Ap_ST32BL.c **** 	for( i=0; i<WriteSize; i++ )
 547              		.loc 1 556 0 is_stmt 0 discriminator 1
 548 004e AE42     		cmp	r6, r5
 549 0050 E6D1     		bne	.L76
 537:../LIB_AP/Lib/Ap_ST32BL.c **** 	u8	Ret = TRUE;
 550              		.loc 1 537 0 is_stmt 1
 551 0052 0120     		movs	r0, #1
 552              	.LVL52:
 553              	.L75:
 566:../LIB_AP/Lib/Ap_ST32BL.c **** 		{
 567:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ret = FALSE;
 568:../LIB_AP/Lib/Ap_ST32BL.c **** 			break;
 569:../LIB_AP/Lib/Ap_ST32BL.c **** 		}
 570:../LIB_AP/Lib/Ap_ST32BL.c **** 	}
 571:../LIB_AP/Lib/Ap_ST32BL.c **** 
 572:../LIB_AP/Lib/Ap_ST32BL.c **** 	return Ret;
 573:../LIB_AP/Lib/Ap_ST32BL.c **** }
 554              		.loc 1 573 0
 555 0054 BDE8FC81 		pop	{r2, r3, r4, r5, r6, r7, r8, pc}
 556              	.L84:
 557              		.align	2
 558              	.L83:
 559 0058 00000000 		.word	Ap_ST32BL_CheckFlashSector
 560 005c 00000000 		.word	FLASH_ProgramWord
 561              		.cfi_endproc
 562              	.LFE7:
 564              		.section	.text.Ap_ST32BL_JumpToApp,"ax",%progbits
 565              		.align	1
 566              		.global	Ap_ST32BL_JumpToApp
 567              		.thumb
 568              		.thumb_func
 570              	Ap_ST32BL_JumpToApp:
 571              	.LFB8:
 574:../LIB_AP/Lib/Ap_ST32BL.c **** 
 575:../LIB_AP/Lib/Ap_ST32BL.c **** 
 576:../LIB_AP/Lib/Ap_ST32BL.c **** 
 577:../LIB_AP/Lib/Ap_ST32BL.c **** 
 578:../LIB_AP/Lib/Ap_ST32BL.c **** extern void PowerOff();
 579:../LIB_AP/Lib/Ap_ST32BL.c **** 
 580:../LIB_AP/Lib/Ap_ST32BL.c **** /*---------------------------------------------------------------------------
 581:../LIB_AP/Lib/Ap_ST32BL.c ****      TITLE   : Ap_ST32BL_JumpToApp
 582:../LIB_AP/Lib/Ap_ST32BL.c ****      WORK    : 
 583:../LIB_AP/Lib/Ap_ST32BL.c ****      ARG     : void
 584:../LIB_AP/Lib/Ap_ST32BL.c ****      RET     : void   
 585:../LIB_AP/Lib/Ap_ST32BL.c **** ---------------------------------------------------------------------------*/
 586:../LIB_AP/Lib/Ap_ST32BL.c **** void Ap_ST32BL_JumpToApp( u32 Address )
 587:../LIB_AP/Lib/Ap_ST32BL.c **** {
 572              		.loc 1 587 0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 0
 575              		@ frame_needed = 0, uses_anonymous_args = 0
 576              	.LVL53:
 588:../LIB_AP/Lib/Ap_ST32BL.c **** 	pFunction JumpToApp;
 589:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 	  JumpAddress;
 590:../LIB_AP/Lib/Ap_ST32BL.c **** 	u32 	  RegData;
 591:../LIB_AP/Lib/Ap_ST32BL.c **** 
 592:../LIB_AP/Lib/Ap_ST32BL.c **** 	//JumpToAddress = (pFunction)(HW_ST32BL_FLASH_START_ADDRESS + 4);
 593:../LIB_AP/Lib/Ap_ST32BL.c **** 
 594:../LIB_AP/Lib/Ap_ST32BL.c **** 
 595:../LIB_AP/Lib/Ap_ST32BL.c **** 	JumpAddress =  *(u32 *)(HW_ST32BL_FLASH_START_ADDRESS + 4);
 577              		.loc 1 595 0
 578 0000 094B     		ldr	r3, .L86
 579              	.LVL54:
 587:../LIB_AP/Lib/Ap_ST32BL.c **** {
 580              		.loc 1 587 0
 581 0002 10B5     		push	{r4, lr}
 582              	.LCFI6:
 583              		.cfi_def_cfa_offset 8
 584              		.cfi_offset 4, -8
 585              		.cfi_offset 14, -4
 596:../LIB_AP/Lib/Ap_ST32BL.c **** 	
 597:../LIB_AP/Lib/Ap_ST32BL.c **** 
 598:../LIB_AP/Lib/Ap_ST32BL.c **** 	JumpToApp = (pFunction) JumpAddress;
 599:../LIB_AP/Lib/Ap_ST32BL.c **** 
 600:../LIB_AP/Lib/Ap_ST32BL.c **** 
 601:../LIB_AP/Lib/Ap_ST32BL.c **** 	//Lb_printf("jump..\n");
 602:../LIB_AP/Lib/Ap_ST32BL.c **** 	Hw_Timer_Delay_ms(100);
 586              		.loc 1 602 0
 587 0004 6420     		movs	r0, #100
 588              	.LVL55:
 589 0006 0949     		ldr	r1, .L86+4
 598:../LIB_AP/Lib/Ap_ST32BL.c **** 	JumpToApp = (pFunction) JumpAddress;
 590              		.loc 1 598 0
 591 0008 1C68     		ldr	r4, [r3, #0]
 592              	.LVL56:
 593              		.loc 1 602 0
 594 000a 8847     		blx	r1
 595              	.LVL57:
 603:../LIB_AP/Lib/Ap_ST32BL.c **** 
 604:../LIB_AP/Lib/Ap_ST32BL.c **** 	//REG_RCC_AHBENR  = 0x00000014;
 605:../LIB_AP/Lib/Ap_ST32BL.c **** 	//REG_RCC_APB1ENR = 0x00000000;
 606:../LIB_AP/Lib/Ap_ST32BL.c **** 	//REG_RCC_APB2ENR = 0x00000000;	
 607:../LIB_AP/Lib/Ap_ST32BL.c **** 
 608:../LIB_AP/Lib/Ap_ST32BL.c **** 	PowerOff();
 596              		.loc 1 608 0
 597 000c 0848     		ldr	r0, .L86+8
 598 000e 8047     		blx	r0
 599              	.LVL58:
 609:../LIB_AP/Lib/Ap_ST32BL.c **** 
 610:../LIB_AP/Lib/Ap_ST32BL.c **** 
 611:../LIB_AP/Lib/Ap_ST32BL.c **** #if 0
 612:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
 613:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Set HSION bit */
 614:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CR |= (uint32_t) 0x00000001;
 615:../LIB_AP/Lib/Ap_ST32BL.c **** 
 616:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
 617:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CFGR &= (uint32_t) 0xF8FF0000;
 618:../LIB_AP/Lib/Ap_ST32BL.c **** 
 619:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset HSEON, CSSON and PLLON bits */
 620:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CR &= (uint32_t) 0xFEF6FFFF;
 621:../LIB_AP/Lib/Ap_ST32BL.c **** 
 622:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset HSEBYP bit */
 623:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CR &= (uint32_t) 0xFFFBFFFF;
 624:../LIB_AP/Lib/Ap_ST32BL.c **** 
 625:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
 626:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CFGR &= (uint32_t) 0xFF80FFFF;
 627:../LIB_AP/Lib/Ap_ST32BL.c **** 
 628:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Disable all interrupts and clear pending bits  */
 629:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_RCC_CIR = 0x009F0000;
 630:../LIB_AP/Lib/Ap_ST32BL.c **** 
 631:../LIB_AP/Lib/Ap_ST32BL.c ****     REG_SCB_VTOR = (uint32_t)0x08000000;     /* Vector Table Relocation in Internal FLASH. */
 632:../LIB_AP/Lib/Ap_ST32BL.c **** #endif
 633:../LIB_AP/Lib/Ap_ST32BL.c **** 
 634:../LIB_AP/Lib/Ap_ST32BL.c **** 
 635:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB1RSTR = 0xFFFFFFFF;
 600              		.loc 1 635 0
 601 0010 0849     		ldr	r1, .L86+12
 636:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB2RSTR = 0xFFFFFFFF;
 602              		.loc 1 636 0
 603 0012 094B     		ldr	r3, .L86+16
 635:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB1RSTR = 0xFFFFFFFF;
 604              		.loc 1 635 0
 605 0014 4FF0FF32 		mov	r2, #-1
 637:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB1RSTR = 0x00000000;
 606              		.loc 1 637 0
 607 0018 0020     		movs	r0, #0
 635:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB1RSTR = 0xFFFFFFFF;
 608              		.loc 1 635 0
 609 001a 0A60     		str	r2, [r1, #0]
 636:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB2RSTR = 0xFFFFFFFF;
 610              		.loc 1 636 0
 611 001c 1A60     		str	r2, [r3, #0]
 612              		.loc 1 637 0
 613 001e 0860     		str	r0, [r1, #0]
 638:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB2RSTR = 0x00000000;
 614              		.loc 1 638 0
 615 0020 1860     		str	r0, [r3, #0]
 639:../LIB_AP/Lib/Ap_ST32BL.c **** 
 640:../LIB_AP/Lib/Ap_ST32BL.c **** 
 641:../LIB_AP/Lib/Ap_ST32BL.c **** 	/*
 642:../LIB_AP/Lib/Ap_ST32BL.c **** 	RegData = 0xFFFFFFFF;
 643:../LIB_AP/Lib/Ap_ST32BL.c **** 
 644:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT(RegData, 17);			// UART2
 645:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT(RegData, 18);			// UART3
 646:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT(RegData, 19);			// UART4
 647:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT(RegData, 20);			// UART5
 648:../LIB_AP/Lib/Ap_ST32BL.c **** 
 649:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB1RSTR = RegData;
 650:../LIB_AP/Lib/Ap_ST32BL.c **** 
 651:../LIB_AP/Lib/Ap_ST32BL.c **** 
 652:../LIB_AP/Lib/Ap_ST32BL.c **** 	RegData = 0xFFFFFFFF;
 653:../LIB_AP/Lib/Ap_ST32BL.c **** 
 654:../LIB_AP/Lib/Ap_ST32BL.c **** 	CLR_BIT(RegData, 14);			// UART1
 655:../LIB_AP/Lib/Ap_ST32BL.c **** 
 656:../LIB_AP/Lib/Ap_ST32BL.c **** 	
 657:../LIB_AP/Lib/Ap_ST32BL.c **** 	REG_RCC_APB2RSTR = RegData;
 658:../LIB_AP/Lib/Ap_ST32BL.c **** 	*/
 659:../LIB_AP/Lib/Ap_ST32BL.c **** 
 660:../LIB_AP/Lib/Ap_ST32BL.c **** 	//-- Remap된 IO가 있으면 초기화
 661:../LIB_AP/Lib/Ap_ST32BL.c **** 	//
 662:../LIB_AP/Lib/Ap_ST32BL.c **** 	//REG_AFIO_MAPR    = 0x00000000;
 663:../LIB_AP/Lib/Ap_ST32BL.c **** 	//REG_AFIO_MAPR2   = 0x00000000;
 664:../LIB_AP/Lib/Ap_ST32BL.c **** 
 665:../LIB_AP/Lib/Ap_ST32BL.c **** 
 666:../LIB_AP/Lib/Ap_ST32BL.c **** 
 667:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CR |= 0x00000001;
 668:../LIB_AP/Lib/Ap_ST32BL.c **** 
 669:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
 670:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CFGR &= 0xF8FF0000;
 671:../LIB_AP/Lib/Ap_ST32BL.c **** 
 672:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset HSEON, CSSON and PLLON bits */
 673:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CR &= 0xFEF6FFFF;
 674:../LIB_AP/Lib/Ap_ST32BL.c **** 
 675:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset HSEBYP bit */
 676:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CR &= 0xFFFBFFFF;
 677:../LIB_AP/Lib/Ap_ST32BL.c **** 
 678:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
 679:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CFGR &= 0xFF80FFFF;
 680:../LIB_AP/Lib/Ap_ST32BL.c **** 
 681:../LIB_AP/Lib/Ap_ST32BL.c ****     /* Disable all interrupts and clear pending bits  */
 682:../LIB_AP/Lib/Ap_ST32BL.c ****     //REG_RCC_CIR = 0x009F0000;
 683:../LIB_AP/Lib/Ap_ST32BL.c **** 
 684:../LIB_AP/Lib/Ap_ST32BL.c **** 
 685:../LIB_AP/Lib/Ap_ST32BL.c **** 
 686:../LIB_AP/Lib/Ap_ST32BL.c **** 	JumpToApp();
 616              		.loc 1 686 0
 617 0022 A047     		blx	r4
 618              	.LVL59:
 619 0024 10BD     		pop	{r4, pc}
 620              	.L87:
 621 0026 00BF     		.align	2
 622              	.L86:
 623 0028 04300008 		.word	134230020
 624 002c 00000000 		.word	Hw_Timer_Delay_ms
 625 0030 00000000 		.word	PowerOff
 626 0034 10100240 		.word	1073877008
 627 0038 0C100240 		.word	1073877004
 628              		.cfi_endproc
 629              	.LFE8:
 631              		.section	.text.Ap_ST32BL_Main,"ax",%progbits
 632              		.align	1
 633              		.global	Ap_ST32BL_Main
 634              		.thumb
 635              		.thumb_func
 637              	Ap_ST32BL_Main:
 638              	.LFB1:
 138:../LIB_AP/Lib/Ap_ST32BL.c **** {
 639              		.loc 1 138 0
 640              		.cfi_startproc
 641              		@ args = 0, pretend = 0, frame = 304
 642              		@ frame_needed = 0, uses_anonymous_args = 0
 643 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 644              	.LCFI7:
 645              		.cfi_def_cfa_offset 28
 646              		.cfi_offset 4, -28
 647              		.cfi_offset 5, -24
 648              		.cfi_offset 6, -20
 649              		.cfi_offset 7, -16
 650              		.cfi_offset 8, -12
 651              		.cfi_offset 9, -8
 652              		.cfi_offset 14, -4
 653 0004 CDB0     		sub	sp, sp, #308
 654              	.LCFI8:
 655              		.cfi_def_cfa_offset 336
 656              	.L113:
 154:../LIB_AP/Lib/Ap_ST32BL.c **** 		Cmd = Ap_ST32BL_WaitCmd();
 657              		.loc 1 154 0
 658 0006 404B     		ldr	r3, .L119
 659 0008 9847     		blx	r3
 660              	.LVL60:
 162:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GET_COMMAND )
 661              		.loc 1 162 0
 662 000a 18B9     		cbnz	r0, .L91
 164:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x00);
 663              		.loc 1 164 0
 664 000c 3F4F     		ldr	r7, .L119+4
 665 000e B847     		blx	r7
 666              	.LVL61:
 165:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x22);
 667              		.loc 1 165 0
 668 0010 2220     		movs	r0, #34
 669 0012 07E0     		b	.L114
 670              	.LVL62:
 671              	.L91:
 170:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GET_ID )
 672              		.loc 1 170 0
 673 0014 0228     		cmp	r0, #2
 674 0016 09D1     		bne	.L93
 172:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x01);
 675              		.loc 1 172 0
 676 0018 0120     		movs	r0, #1
 677              	.LVL63:
 678 001a 3C4F     		ldr	r7, .L119+4
 679 001c B847     		blx	r7
 680              	.LVL64:
 173:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x04);
 681              		.loc 1 173 0
 682 001e 0420     		movs	r0, #4
 683 0020 B847     		blx	r7
 684              	.LVL65:
 174:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(0x10);
 685              		.loc 1 174 0
 686 0022 1020     		movs	r0, #16
 687              	.L114:
 688 0024 B847     		blx	r7
 689              	.LVL66:
 175:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);			
 690              		.loc 1 175 0
 691 0026 7920     		movs	r0, #121
 692 0028 B847     		blx	r7
 693              	.LVL67:
 694 002a ECE7     		b	.L113
 695              	.LVL68:
 696              	.L93:
 179:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_ERASE_FLASH )
 697              		.loc 1 179 0
 698 002c 4328     		cmp	r0, #67
 699 002e 0CD1     		bne	.L94
 181:../LIB_AP/Lib/Ap_ST32BL.c **** 			Resp[0] = Ap_ST32BL_ReceiveByte();
 700              		.loc 1 181 0
 701 0030 374E     		ldr	r6, .L119+8
 702 0032 B047     		blx	r6
 703              	.LVL69:
 704 0034 8DF80400 		strb	r0, [sp, #4]
 182:../LIB_AP/Lib/Ap_ST32BL.c **** 			Resp[1] = Ap_ST32BL_ReceiveByte();
 705              		.loc 1 182 0
 706 0038 B047     		blx	r6
 707              	.LVL70:
 185:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( Ap_ST32BL_EraseFlash() == TRUE )	Ap_ST32BL_SendByte(STM32_COMM_ACK);
 708              		.loc 1 185 0
 709 003a 364A     		ldr	r2, .L119+12
 182:../LIB_AP/Lib/Ap_ST32BL.c **** 			Resp[1] = Ap_ST32BL_ReceiveByte();
 710              		.loc 1 182 0
 711 003c 8DF80500 		strb	r0, [sp, #5]
 185:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( Ap_ST32BL_EraseFlash() == TRUE )	Ap_ST32BL_SendByte(STM32_COMM_ACK);
 712              		.loc 1 185 0
 713 0040 9047     		blx	r2
 714              	.LVL71:
 715              	.L117:
 716 0042 0128     		cmp	r0, #1
 717 0044 3AD1     		bne	.L95
 185:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( Ap_ST32BL_EraseFlash() == TRUE )	Ap_ST32BL_SendByte(STM32_COMM_ACK);
 718              		.loc 1 185 0 is_stmt 0 discriminator 1
 719 0046 7920     		movs	r0, #121
 720 0048 39E0     		b	.L115
 721              	.LVL72:
 722              	.L94:
 196:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_WRITE_FLASH )
 723              		.loc 1 196 0 is_stmt 1
 724 004a 3128     		cmp	r0, #49
 725 004c 3CD1     		bne	.L97
 726 004e 0025     		movs	r5, #0
 727 0050 2E46     		mov	r6, r5
 728              	.LVL73:
 729              	.L98:
 204:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 730              		.loc 1 204 0 discriminator 2
 731 0052 2F4F     		ldr	r7, .L119+8
 732 0054 B847     		blx	r7
 733              	.LVL74:
 734 0056 01AC     		add	r4, sp, #4
 735 0058 3055     		strb	r0, [r6, r4]
 202:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<4; i++ )
 736              		.loc 1 202 0 discriminator 2
 737 005a 0136     		adds	r6, r6, #1
 738 005c 042E     		cmp	r6, #4
 205:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];	
 739              		.loc 1 205 0 discriminator 2
 740 005e 85EA0005 		eor	r5, r5, r0
 741              	.LVL75:
 202:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<4; i++ )
 742              		.loc 1 202 0 discriminator 2
 743 0062 F6D1     		bne	.L98
 207:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 744              		.loc 1 207 0
 745 0064 B847     		blx	r7
 746              	.LVL76:
 209:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 747              		.loc 1 209 0
 748 0066 94F80090 		ldrb	r9, [r4, #0]	@ zero_extendqisi2
 210:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 749              		.loc 1 210 0
 750 006a 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 209:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 751              		.loc 1 209 0
 752 006c 4FEA0962 		lsl	r2, r9, #24
 211:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 753              		.loc 1 211 0
 754 0070 A778     		ldrb	r7, [r4, #2]	@ zero_extendqisi2
 210:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 755              		.loc 1 210 0
 756 0072 42EA0341 		orr	r1, r2, r3, lsl #16
 212:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;
 757              		.loc 1 212 0
 758 0076 E478     		ldrb	r4, [r4, #3]	@ zero_extendqisi2
 759              	.LVL77:
 211:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 760              		.loc 1 211 0
 761 0078 41EA0726 		orr	r6, r1, r7, lsl #8
 762              	.LVL78:
 220:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( CheckSum == CheckSumCalc )
 763              		.loc 1 220 0
 764 007c A842     		cmp	r0, r5
 212:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;
 765              		.loc 1 212 0
 766 007e 46EA0409 		orr	r9, r6, r4
 767              	.LVL79:
 768 0082 224D     		ldr	r5, .L119+4
 769              	.LVL80:
 220:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( CheckSum == CheckSumCalc )
 770              		.loc 1 220 0
 771 0084 1ED1     		bne	.L99
 222:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_ACK);
 772              		.loc 1 222 0
 773 0086 7920     		movs	r0, #121
 774              	.LVL81:
 775              	.L118:
 229:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_NACK);	
 776              		.loc 1 229 0
 777 0088 A847     		blx	r5
 778              	.LVL82:
 239:../LIB_AP/Lib/Ap_ST32BL.c **** 			Length  = Ap_ST32BL_ReceiveByte();
 779              		.loc 1 239 0
 780 008a 2148     		ldr	r0, .L119+8
 781 008c 8047     		blx	r0
 782              	.LVL83:
 247:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<Length; i++ )
 783              		.loc 1 247 0
 784 008e 0025     		movs	r5, #0
 239:../LIB_AP/Lib/Ap_ST32BL.c **** 			Length  = Ap_ST32BL_ReceiveByte();
 785              		.loc 1 239 0
 786 0090 0446     		mov	r4, r0
 787              	.LVL84:
 241:../LIB_AP/Lib/Ap_ST32BL.c **** 			Length++;
 788              		.loc 1 241 0
 789 0092 461C     		adds	r6, r0, #1
 790              	.LVL85:
 791              	.L101:
 249:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 792              		.loc 1 249 0 discriminator 2
 793 0094 DFF87880 		ldr	r8, .L119+8
 794 0098 C047     		blx	r8
 795              	.LVL86:
 796 009a 01AF     		add	r7, sp, #4
 797 009c E855     		strb	r0, [r5, r7]
 247:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<Length; i++ )
 798              		.loc 1 247 0 discriminator 2
 799 009e 0135     		adds	r5, r5, #1
 250:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];					
 800              		.loc 1 250 0 discriminator 2
 801 00a0 4440     		eors	r4, r4, r0
 247:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<Length; i++ )
 802              		.loc 1 247 0 discriminator 2
 803 00a2 B542     		cmp	r5, r6
 250:../LIB_AP/Lib/Ap_ST32BL.c **** 				CheckSumCalc ^= Resp[i];					
 804              		.loc 1 250 0 discriminator 2
 805 00a4 E4B2     		uxtb	r4, r4
 806              	.LVL87:
 247:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<Length; i++ )
 807              		.loc 1 247 0 discriminator 2
 808 00a6 F5D3     		bcc	.L101
 252:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 809              		.loc 1 252 0
 810 00a8 C047     		blx	r8
 811              	.LVL88:
 263:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ret = Ap_ST32BL_WriteFlash( Address + HW_ST32BL_FLASH_ADDRESS_OFFSET, Resp, Length );
 812              		.loc 1 263 0
 813 00aa 3946     		mov	r1, r7
 252:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 814              		.loc 1 252 0
 815 00ac 0546     		mov	r5, r0
 816              	.LVL89:
 263:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ret = Ap_ST32BL_WriteFlash( Address + HW_ST32BL_FLASH_ADDRESS_OFFSET, Resp, Length );
 817              		.loc 1 263 0
 818 00ae 3246     		mov	r2, r6
 819 00b0 09F54050 		add	r0, r9, #12288
 820              	.LVL90:
 821 00b4 184B     		ldr	r3, .L119+16
 822 00b6 9847     		blx	r3
 823              	.LVL91:
 266:../LIB_AP/Lib/Ap_ST32BL.c **** 			if( CheckSum == CheckSumCalc && Ret == TRUE ) 	
 824              		.loc 1 266 0
 825 00b8 A542     		cmp	r5, r4
 826 00ba C2D0     		beq	.L117
 827              	.LVL92:
 828              	.L95:
 186:../LIB_AP/Lib/Ap_ST32BL.c **** 			else									Ap_ST32BL_SendByte(STM32_COMM_NACK);
 829              		.loc 1 186 0
 830 00bc 1F20     		movs	r0, #31
 831              	.L115:
 832 00be 1349     		ldr	r1, .L119+4
 833 00c0 8847     		blx	r1
 834              	.LVL93:
 835 00c2 A0E7     		b	.L113
 836              	.LVL94:
 837              	.L99:
 229:../LIB_AP/Lib/Ap_ST32BL.c **** 				Ap_ST32BL_SendByte(STM32_COMM_NACK);	
 838              		.loc 1 229 0
 839 00c4 1F20     		movs	r0, #31
 840              	.LVL95:
 841 00c6 DFE7     		b	.L118
 842              	.LVL96:
 843              	.L97:
 280:../LIB_AP/Lib/Ap_ST32BL.c **** 		if( Cmd == STM32_CMD_GO )
 844              		.loc 1 280 0
 845 00c8 2128     		cmp	r0, #33
 846 00ca 9CD1     		bne	.L113
 847 00cc 0025     		movs	r5, #0
 848              	.LVL97:
 849              	.L104:
 287:../LIB_AP/Lib/Ap_ST32BL.c **** 				Resp[i] = Ap_ST32BL_ReceiveByte();
 850              		.loc 1 287 0 discriminator 2
 851 00ce 104E     		ldr	r6, .L119+8
 852 00d0 B047     		blx	r6
 853              	.LVL98:
 854 00d2 01AC     		add	r4, sp, #4
 855 00d4 6055     		strb	r0, [r4, r5]
 285:../LIB_AP/Lib/Ap_ST32BL.c **** 			for( i=0; i<4; i++ )
 856              		.loc 1 285 0 discriminator 2
 857 00d6 0135     		adds	r5, r5, #1
 858              	.LVL99:
 859 00d8 042D     		cmp	r5, #4
 860 00da F8D1     		bne	.L104
 290:../LIB_AP/Lib/Ap_ST32BL.c **** 			CheckSum = Ap_ST32BL_ReceiveByte();
 861              		.loc 1 290 0
 862 00dc B047     		blx	r6
 863              	.LVL100:
 292:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 864              		.loc 1 292 0
 865 00de 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 293:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 866              		.loc 1 293 0
 867 00e0 6078     		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 294:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 868              		.loc 1 294 0
 869 00e2 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 292:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address  = Resp[0] << 24;
 870              		.loc 1 292 0
 871 00e4 1706     		lsls	r7, r2, #24
 293:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[1] << 16;
 872              		.loc 1 293 0
 873 00e6 47EA0041 		orr	r1, r7, r0, lsl #16
 295:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;	
 874              		.loc 1 295 0
 875 00ea E478     		ldrb	r4, [r4, #3]	@ zero_extendqisi2
 876              	.LVL101:
 294:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[2] <<  8;
 877              		.loc 1 294 0
 878 00ec 41EA0326 		orr	r6, r1, r3, lsl #8
 879              	.LVL102:
 298:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_SendByte(STM32_COMM_ACK);	
 880              		.loc 1 298 0
 881 00f0 7920     		movs	r0, #121
 882 00f2 064A     		ldr	r2, .L119+4
 883 00f4 9047     		blx	r2
 884              	.LVL103:
 295:../LIB_AP/Lib/Ap_ST32BL.c **** 			Address |= Resp[3] <<  0;	
 885              		.loc 1 295 0
 886 00f6 46EA0405 		orr	r5, r6, r4
 887              	.LVL104:
 300:../LIB_AP/Lib/Ap_ST32BL.c **** 			Hw_Timer_Delay_ms(100);
 888              		.loc 1 300 0
 889 00fa 6420     		movs	r0, #100
 890 00fc 074F     		ldr	r7, .L119+20
 891 00fe B847     		blx	r7
 892              	.LVL105:
 304:../LIB_AP/Lib/Ap_ST32BL.c **** 			Ap_ST32BL_JumpToApp( Address );
 893              		.loc 1 304 0
 894 0100 2846     		mov	r0, r5
 895 0102 0749     		ldr	r1, .L119+24
 896 0104 8847     		blx	r1
 897              	.LVL106:
 898 0106 7EE7     		b	.L113
 899              	.L120:
 900              		.align	2
 901              	.L119:
 902 0108 00000000 		.word	Ap_ST32BL_WaitCmd
 903 010c 00000000 		.word	Ap_ST32BL_SendByte
 904 0110 00000000 		.word	Ap_ST32BL_ReceiveByte
 905 0114 00000000 		.word	Ap_ST32BL_EraseFlash
 906 0118 00000000 		.word	Ap_ST32BL_WriteFlash
 907 011c 00000000 		.word	Hw_Timer_Delay_ms
 908 0120 00000000 		.word	Ap_ST32BL_JumpToApp
 909              		.cfi_endproc
 910              	.LFE1:
 912              		.comm	Ap_ST32BL_EraseSectorFlag,128,1
 913              		.comm	Ap_ST32BL_UartPort,1,1
 914              		.comm	Ap_ST32BL_RunBoot,1,1
 915              		.text
 916              	.Letext0:
 917              		.file 2 "../LIB_HW/Core/Hw_Define.h"
 918              		.file 3 "../LIB_AP/Lib/Ap_ST32BL.h"
 919              		.file 4 "../LIB_HW/Driver/LIB_ST32/stm32f10x_flash.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Ap_ST32BL.c
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:19     .text.Ap_ST32BL_Init:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:24     .text.Ap_ST32BL_Init:0000000000000000 Ap_ST32BL_Init
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:105    .text.Ap_ST32BL_Init:0000000000000064 $d
                            *COM*:0000000000000001 Ap_ST32BL_RunBoot
                            *COM*:0000000000000080 Ap_ST32BL_EraseSectorFlag
                            *COM*:0000000000000001 Ap_ST32BL_UartPort
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:115    .text.Ap_ST32BL_SendByte:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:120    .text.Ap_ST32BL_SendByte:0000000000000000 Ap_ST32BL_SendByte
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:146    .text.Ap_ST32BL_SendByte:0000000000000010 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:152    .text.Ap_ST32BL_ReceiveByte:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:157    .text.Ap_ST32BL_ReceiveByte:0000000000000000 Ap_ST32BL_ReceiveByte
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:179    .text.Ap_ST32BL_ReceiveByte:000000000000000c $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:185    .text.Ap_ST32BL_WaitCmd:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:190    .text.Ap_ST32BL_WaitCmd:0000000000000000 Ap_ST32BL_WaitCmd
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:268    .text.Ap_ST32BL_WaitCmd:0000000000000050 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:274    .text.Ap_ST32BL_EraseFlash:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:279    .text.Ap_ST32BL_EraseFlash:0000000000000000 Ap_ST32BL_EraseFlash
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:354    .text.Ap_ST32BL_EraseFlash:0000000000000040 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:364    .text.Ap_ST32BL_CheckFlashSector:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:369    .text.Ap_ST32BL_CheckFlashSector:0000000000000000 Ap_ST32BL_CheckFlashSector
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:447    .text.Ap_ST32BL_CheckFlashSector:0000000000000048 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:455    .text.Ap_ST32BL_WriteFlash:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:460    .text.Ap_ST32BL_WriteFlash:0000000000000000 Ap_ST32BL_WriteFlash
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:559    .text.Ap_ST32BL_WriteFlash:0000000000000058 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:565    .text.Ap_ST32BL_JumpToApp:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:570    .text.Ap_ST32BL_JumpToApp:0000000000000000 Ap_ST32BL_JumpToApp
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:623    .text.Ap_ST32BL_JumpToApp:0000000000000028 $d
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:632    .text.Ap_ST32BL_Main:0000000000000000 $t
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:637    .text.Ap_ST32BL_Main:0000000000000000 Ap_ST32BL_Main
/var/folders/bz/nn5481rn5xq59rb0mbj7x0880000gn/T//ccbFLUWO.s:902    .text.Ap_ST32BL_Main:0000000000000108 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
Hw_Uart_Putch
Hw_Uart_Getch
FLASH_Unlock
FLASH_ClearFlag
FLASH_ErasePage
FLASH_Lock
FLASH_ProgramWord
Hw_Timer_Delay_ms
PowerOff
